import { jaroWrinkerSimilarity } from './string-similarity';
import { resolvePointer, Condition, testPointerCondition, getType, getPropertyIntersection } from './utils';

export interface PotentialMatch {
    leftElementIndex: number;
    rightElementIndex: number;
    confidence?: number; // only used in similarity functions
}

/**
 * Instructions generated by a constraint that tell the comparator how to match up indices of an array pair.
 */
export interface MatchInstructions {
    matchedIndices: PotentialMatch[];
    unmatchedLeftIndices: number[];
    unmatchedRightIndices: number[];
}

export type MatchType = 'literal' | 'string-similarity';

type ConstraintConditionTuple = [Condition, AbstractMatchConstraint];

/**
 * This object houses match constraints and provides the ability to search
 * through all the match constraints.
 */
export class MatchConstraintsContainer {
    private constraints: ConstraintConditionTuple[];

    public tryGetConstraint(pointer: string) {
        for (const constraint of this.constraints) {
            if (testPointerCondition(pointer, constraint[0])) {
                return constraint[1];
            }
        }
        return null;
    }

    constructor(constraints: ConstraintConditionTuple[]) {
        this.constraints = constraints;
    }

    /**
     * Create constraints container from dictionary.
     * This object should be a map from the `condition` to the `constraint`,
     * where each condition is a string and each `constraint` is an object.
     * @param obj Dictionary (parsed JSON/YAML) object
     */
    public static fromDict(obj: any): MatchConstraintsContainer {
        const constraints: ConstraintConditionTuple[] = [];
        for (const condition of Object.getOwnPropertyNames(obj)) {
            const constraint = MatchConstraintfromDict(obj[condition]);
            const constraintTuple = [condition, constraint] as ConstraintConditionTuple;
            constraints.push(constraintTuple);
        }
        return new MatchConstraintsContainer(constraints);
    }
}

function MatchConstraintfromDict(obj: any): AbstractMatchConstraint {
    if (!obj.hasOwnProperty('type')) {
        throw new Error(`Error decoding object ${obj} into MatchConstraint`);
    }

    switch (obj['type'] as string) {
        case PrimitiveMatchConstraint.name:
            return PrimitiveMatchConstraint.fromDict(obj);
        case ObjectPropertyMatchConstraint.name:
            return ObjectPropertyMatchConstraint.fromDict(obj);
        default:
            throw new Error(`Unkown match constraint: ${obj['type']}`);
    }
}

export abstract class AbstractMatchConstraint {
    abstract scoreElementPair(leftElement: any, rightElement: any): number;

    public matchArrayElements(leftArray: any[], rightArray: any[]): MatchInstructions {
        const instructions: MatchInstructions = {
            matchedIndices: [],
            unmatchedLeftIndices: [],
            unmatchedRightIndices: [],
        };

        const rightArrayIndices = [...rightArray.keys()];
        for (let leftElementIndex = 0; leftElementIndex < leftArray.length; leftElementIndex++) {
            const leftElement = leftArray[leftElementIndex];
            let topScore = 0;
            let topScoreIndex = -1;
            for (const rightElementIndex of rightArrayIndices) {
                const rightElement = rightArray[rightElementIndex];
                const score = this.scoreElementPair(leftElement, rightElement);
                if (score > topScore) {
                    topScore = score;
                    topScoreIndex = rightElementIndex;
                    if (score === 1) break;
                }
            }
            if (topScoreIndex === -1) {
                instructions.unmatchedLeftIndices.push(leftElementIndex);
            } else {
                const deleteIndex = rightArrayIndices.indexOf(topScoreIndex);
                rightArrayIndices.splice(deleteIndex, 1);
                instructions.matchedIndices.push({
                    leftElementIndex,
                    rightElementIndex: topScoreIndex,
                });
            }
        }

        instructions.unmatchedRightIndices = rightArrayIndices;

        return instructions;
    }

    public static fromDict(_: any): AbstractMatchConstraint {
        throw new Error('Not implemented');
    }
}

export class PrimitiveMatchConstraint extends AbstractMatchConstraint {
    matchType: MatchType;

    scoreElementPair(leftElement: any, rightElement: any): number {
        if (this.matchType === 'literal') {
            return leftElement === rightElement ? 1 : 0;
        } else if (this.matchType === 'string-similarity') {
            return jaroWrinkerSimilarity(leftElement, rightElement);
        } else {
            throw new Error('unknown comparison type');
        }
    }

    public constructor(matchType: MatchType) {
        super();
        this.matchType = matchType;
    }

    public static fromDict(obj: any): AbstractMatchConstraint {
        if (!obj.hasOwnProperty('matchType')) {
            throw new Error(`Error decoding object ${obj} into ${ObjectPropertyMatchConstraint.name}`);
        }

        return new PrimitiveMatchConstraint(obj['matchType'] as MatchType);
    }
}

export class ObjectPropertyMatchConstraint extends AbstractMatchConstraint {
    matchType: MatchType;
    propertyName: string;
    secondaryProperties?: string;

    scoreElementPair(leftElement: any, rightElement: any): number {
        if (this.secondaryProperties) {
            for (const secondaryProperty of this.secondaryProperties) {
                if (leftElement[secondaryProperty] !== rightElement[secondaryProperty]) {
                    return 0;
                }
            }
        }

        try {
            const leftSubProperty = resolvePointer(leftElement, this.propertyName);
            const rightSubProperty = resolvePointer(rightElement, this.propertyName);

            if (this.matchType === 'literal') {
                return leftSubProperty === rightSubProperty ? 1 : 0;
            } else if (this.matchType === 'string-similarity') {
                return jaroWrinkerSimilarity(leftSubProperty, rightSubProperty);
            } else {
                throw new Error('unknown comparison type');
            }
        } catch (error) {
            return 0;
        }
    }

    public constructor(matchType: MatchType, propertyName: string, secondaryProperties?: string) {
        super();
        this.matchType = matchType;
        this.propertyName = propertyName;
        this.secondaryProperties = secondaryProperties;
    }

    public static fromDict(obj: any): AbstractMatchConstraint {
        if (!obj.hasOwnProperty('matchType') || !obj.hasOwnProperty('propertyName') || !obj.hasOwnProperty('secondaryProperties')) {
            throw new Error(`Error decoding object ${obj} into ${ObjectPropertyMatchConstraint.name}`);
        }

        return new ObjectPropertyMatchConstraint(
            obj['matchType'] as MatchType,
            obj['propertyName'],
            obj['secondaryProperties'],
        );
    }
}

export function generatePotentialMatches(leftArray: any[], rightArray: any[]): MatchInstructions[] {
    const potentialMatches: MatchInstructions[] = [{ // include match instructions with no matched indices
        matchedIndices: [],
        unmatchedLeftIndices: [...leftArray.keys()],
        unmatchedRightIndices: [...rightArray.keys()],
    }];

    if (leftArray.length > 0 && rightArray.length > 0) {
        // only try matching if an array item can be sampled from both
        const leftSample = leftArray[0];
        const rightSample = rightArray[0];
        // sample left and right arrays
        const type = getType(leftSample);
        if (type !== getType(rightSample)) {
            throw new Error('Left and right arrays cannot mix and match type');
        }

        if (type === 'array') {
            throw new Error('Array of array comparison between two objects is not supported');
        } else if (type === 'object') {
            for (const property of getPropertyIntersection(leftSample, rightSample)) {
                for (const matchType of ['literal', 'string-similarity']) {
                    const constraint = new ObjectPropertyMatchConstraint(matchType as MatchType, property);
                    potentialMatches.push(constraint.matchArrayElements(leftArray, rightArray));
                }
            }
        } else { // comparing primitives
            for (const matchType of ['literal', 'string-similarity']) {
                const constraint = new PrimitiveMatchConstraint(matchType as MatchType);
                potentialMatches.push(constraint.matchArrayElements(leftArray, rightArray));
            }
        }
    }

    return potentialMatches;
}
